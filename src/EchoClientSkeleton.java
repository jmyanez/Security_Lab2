import java.io.*;
import java.net.*;
import java.security.*;
import java.util.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.security.MessageDigest;

public class EchoClientSkeleton {
    // This code includes socket code originally provided
    // by Dr. Yoonsik Cheon at least 10 years ago.
    // This version used for Computer Security, Spring 2018.



    public static void main(String[] args) {



        //String host = "localhost";
        String host = "cspl000.utep.edu";
        BufferedReader in; // for reading strings from socket
        PrintWriter out;   // for writing strings to socket
        ObjectInputStream objectInput;   // for reading objects from socket
        ObjectOutputStream objectOutput; // for writing objects to socket
        Cipher  cipherEnc, cipherDec;
        byte[] clientRandomBytes;
        PublicKey[] pkpair;
        Socket socket;
        VerifyCert verif = new VerifyCert(); //New instance to  call verCert
        byte[] serverRandomBytes;

        // Handshake
        try {
            // socket initialization 1
            socket = new Socket(host, 8008);
            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream()));
            out.flush();
        } catch (IOException e) {
            System.out.println("socket initialization error");
            return;
        }
        // Send hello to server
        out.println("hello");
        out.flush();
        // Receive Server certificate
        // Will need to verify the certificate and extract the Server public keys
        //pk[0] server publi
        //pk[1] signature public

          pkpair = VerifyCert.vCert(in); // Certificate received and verified 2,3


        try {
            // read and send certificate to server   4,5
            File file = new File("certificate.txt");
            Scanner input = new Scanner(file);
            String line;
            System.out.println("Sending Cert!!!");
            while (input.hasNextLine()) {
                line = input.nextLine();
                out.println(line);
            }
            out.flush();
        } catch (FileNotFoundException e){
            System.out.println("certificate file not found");
            return;
        }
        try {
            // initialize object streams
            objectOutput = new ObjectOutputStream(socket.getOutputStream());
            objectInput = new ObjectInputStream(socket.getInputStream());
            // receive encrypted random bytes from server 6,7,8
            byte[] encryptedBytes = (byte[]) objectInput.readObject();
            // receive signature of hash of random bytes from server
            byte[] signatureBytes = (byte[]) objectInput.readObject();
            // will need to verify the signature and decrypt the random bytes 8
            Decrypt decr = new Decrypt();
            serverRandomBytes = decr.decrytp2(encryptedBytes);
            //System.out.println("Decrypted bytes " + serverRandomBytes[0]);
            byte[] hashedDecryptedBytes = genSHA256(serverRandomBytes);
            Verify v1 = new Verify();
            v1.verify(pkpair[1],hashedDecryptedBytes,signatureBytes);

        } catch (IOException | ClassNotFoundException ex) {
            System.out.println("Problem with receiving random bytes from server");
            return;
        }
        // generate random bytes for shared secret 9
        clientRandomBytes = new byte[8];
        // the next line would initialize the byte array to random values 9
        new Random().nextBytes(clientRandomBytes);
        try {
            // you need to encrypt and send the the random byte array 9
            Encrypt encryptor = new Encrypt();
            byte[] clientEncBytes = encryptor.encrypt2(pkpair[0],clientRandomBytes);
            objectOutput.writeObject(clientEncBytes);

            // you need to generate a signature of the hash of the random bytes

            byte[] hashedRandomBytes = genSHA256(clientRandomBytes);
            PrivateKey pk = PemUtils.readPrivateKey("JYServerSignprivateKey.pem");
            byte[] hashSignature = Sign.sign(pk, hashedRandomBytes);
            objectOutput.writeObject(hashSignature);
            System.out.println("Hash signed sent!");

        } catch (IOException e) {
            System.out.println("error computing or sending the signature for random bytes");
            return;
        }
        // initialize the shared secret with our random generated bytes
        // will need to generate from a combination of the server and
        // the client random bytes generated

        byte[] sharedSecret = new byte[16];
        System.arraycopy(serverRandomBytes, 0, sharedSecret, 0, 8);
        System.arraycopy(clientRandomBytes,  0, sharedSecret, 8, 8);
        try {
            SecretKeySpec secretKey = new SecretKeySpec(sharedSecret,"AES"); // AES key
            //Ciphers creation
            cipherEnc = Cipher.getInstance("AES/CBC/PKCS5Padding");
            cipherDec = Cipher.getInstance("AES/CBC/PKCS5Padding");



            //Encryption Cipher creation
            cipherEnc.init(Cipher.ENCRYPT_MODE,secretKey);
            byte[] iv = cipherEnc.getIV();
            objectOutput.writeObject(iv); // Sending to server Client iv

            // Decryption cipher creation

            iv  = (byte[])  objectInput.readObject();// Receive iv from Server  // < ------ AQUI ESTA EL ERROR :)
            cipherDec.init(Cipher.DECRYPT_MODE,secretKey,new IvParameterSpec(iv));
        } catch (IOException | NoSuchAlgorithmException
                | NoSuchPaddingException|InvalidParameterException |ClassNotFoundException |InvalidAlgorithmParameterException  | InvalidKeyException e) {
            System.out.println("error setting up the AES encryption");
            e.printStackTrace();
            return;
        }
        try {
            // Encrypted communication
            System.out.println("Starting messages to the server. Type messages, type BYE to end");
            Scanner userInput = new Scanner(System.in);
            boolean done = false;
            while (!done) {
                // Read message from the user
                String userStr = userInput.nextLine();
                // Encrypt the message
                byte[] encryptedBytes = cipherEnc.doFinal(userStr.getBytes());
                // Send encrypted message as an object to the server
                objectOutput.writeObject(encryptedBytes);
                // If user says "BYE", end session
                if (userStr.trim().equals("BYE")) {
                    System.out.println("client session ended");
                    done = true;
                } else {
                    // Wait for reply from server,
                    encryptedBytes = (byte[]) objectInput.readObject();
                    String str = new String(cipherDec.doFinal(encryptedBytes));
                    // will need to decrypt and print the reply to the screen
                    System.out.println(str);
                    System.out.println("Encrypted echo received,and decrypted");
                }
            }
        } catch (IllegalBlockSizeException | BadPaddingException
                | IOException | ClassNotFoundException e) {
            System.out.println("error in encrypted communication with server");
        }
    }
    public static byte[] genSHA256(byte[] myHash){
        try {
            MessageDigest hash = MessageDigest.getInstance("SHA-256");
            hash.update(myHash);
            return hash.digest();
        }
        catch (NoSuchAlgorithmException e){
            System.out.println("No such alg found");
            return null;
        }
    }
}


